head	1.1;
access;
symbols;
locks
	green:1.1; strict;
comment	@;;; @;


1.1
date	2026.01.01.12.35.43;	author green;	state Exp;
branches;
next	;


desc
@@


1.1
log
@'Before ocicl lint --fix'
@
text
@;;; abnf.lisp
;;;
;;; SPDX-License-Identifier: EPL-1.0
;;;
;;; Copyright (C) 2026 Anthony Green <green@@moxielogic.com>
;;;
;;; This is a Common Lisp port of instaparse by Mark Engelberg.
;;; Original: https://github.com/Engelberg/instaparse
;;; Licensed under the Eclipse Public License 1.0.
;;;
;;; ABNF (Augmented Backus-Naur Form) Parser
;;; Implements RFC 5234 ABNF notation support.

(in-package #:iparse/abnf)

;;;; ABNF Core Rules (RFC 5234 Appendix B)

(defvar *abnf-core*
  (let ((grammar (make-hash-table :test 'eq)))
    (setf (gethash :alpha grammar) (make-regexp-parser "[a-zA-Z]"))
    (setf (gethash :bit grammar) (make-regexp-parser "[01]"))
    (setf (gethash :char grammar) (make-regexp-parser "[\\x01-\\x7F]"))
    (setf (gethash :cr grammar) (make-string-parser (string #\Return)))
    (setf (gethash :crlf grammar) (make-string-parser (coerce '(#\Return #\Newline) 'string)))
    (setf (gethash :ctl grammar) (make-regexp-parser "[\\x00-\\x1F\\x7F]"))
    (setf (gethash :digit grammar) (make-regexp-parser "[0-9]"))
    (setf (gethash :dquote grammar) (make-string-parser "\""))
    (setf (gethash :hexdig grammar) (make-regexp-parser "[0-9a-fA-F]"))
    (setf (gethash :htab grammar) (make-string-parser (string #\Tab)))
    (setf (gethash :lf grammar) (make-string-parser (string #\Newline)))
    (setf (gethash :lwsp grammar)
          (make-alt
           (make-alt (make-string-parser " ") (make-string-parser (string #\Tab)))
           (make-star
            (make-cat (make-string-parser (coerce '(#\Return #\Newline) 'string))
                      (make-alt (make-string-parser " ")
                                (make-string-parser (string #\Tab)))))))
    (setf (gethash :octet grammar) (make-regexp-parser "[\\x00-\\xFF]"))
    (setf (gethash :sp grammar) (make-string-parser " "))
    (setf (gethash :vchar grammar) (make-regexp-parser "[\\x21-\\x7E]"))
    (setf (gethash :wsp grammar)
          (make-alt (make-string-parser " ")
                    (make-string-parser (string #\Tab))))
    grammar)
  "Core ABNF rules from RFC 5234 Appendix B.")


;;;; ABNF Meta-Grammar

(defun make-abnf-grammar ()
  "Build the meta-grammar for parsing ABNF notation."
  (let ((grammar (make-hash-table :test 'eq)))

    ;; Whitespace and comments
    (setf (gethash :opt-whitespace grammar)
          (hide (make-regexp-parser "\\s*(?:;.*?(?:\\r?\\n|$))*")))

    (setf (gethash :whitespace grammar)
          (hide (make-regexp-parser "\\s+(?:;.*?\\r?\\n\\s*)*")))

    ;; Top-level rules
    (setf (gethash :rulelist grammar)
          (hide-tag
           (make-cat
            (make-nt :opt-whitespace)
            (make-plus
             (make-alt (make-nt :rule) (make-nt :hide-tag-rule))))))

    (setf (gethash :rule grammar)
          (make-cat
           (make-nt :rulename-left)
           (hide (make-nt :defined-as))
           (make-nt :alternation)
           (make-nt :opt-whitespace)))

    (setf (gethash :hide-tag-rule grammar)
          (make-cat
           (make-nt :hide-tag)
           (hide (make-nt :defined-as))
           (make-nt :alternation)
           (make-nt :opt-whitespace)))

    (setf (gethash :hide-tag grammar)
          (make-cat
           (hide (make-string-parser "<"))
           (make-nt :opt-whitespace)
           (make-nt :rulename-left)
           (make-nt :opt-whitespace)
           (hide (make-string-parser ">"))))

    (setf (gethash :rulename-left grammar)
          (make-nt :rulename))

    (setf (gethash :rulename-right grammar)
          (make-nt :rulename))

    (setf (gethash :rulename grammar)
          (make-regexp-parser "[a-zA-Z][-a-zA-Z0-9]*"))

    (setf (gethash :defined-as grammar)
          (make-cat
           (make-nt :opt-whitespace)
           (make-alt (make-string-parser "=/")
                     (make-string-parser "="))
           (make-nt :opt-whitespace)))

    ;; Alternation
    (setf (gethash :alternation grammar)
          (make-cat
           (make-nt :concatenation)
           (make-star
            (make-cat
             (make-nt :opt-whitespace)
             (hide (make-string-parser "/"))
             (make-nt :opt-whitespace)
             (make-nt :concatenation)))))

    ;; Concatenation
    (setf (gethash :concatenation grammar)
          (make-cat
           (make-nt :repetition)
           (make-star
            (make-cat
             (make-nt :whitespace)
             (make-nt :repetition)))))

    ;; Repetition
    (setf (gethash :repetition grammar)
          (make-cat
           (make-opt (make-nt :repeat))
           (make-nt :opt-whitespace)
           (make-nt :element)))

    (setf (gethash :repeat grammar)
          (make-alt
           (make-cat
            (make-opt (make-nt :num))
            (make-string-parser "*")
            (make-opt (make-nt :num)))
           (make-nt :num)))

    (setf (gethash :num grammar)
          (make-plus (make-regexp-parser "[0-9]")))

    ;; Element
    (setf (gethash :element grammar)
          (make-alt
           (make-nt :rulename-right)
           (make-nt :group)
           (make-nt :option)
           (make-nt :hide)
           (make-nt :char-val)
           (make-nt :num-val)
           (make-nt :look)
           (make-nt :neg)
           (make-nt :regexp)))

    ;; Grouping
    (setf (gethash :group grammar)
          (make-cat
           (hide (make-string-parser "("))
           (make-nt :opt-whitespace)
           (make-nt :alternation)
           (make-nt :opt-whitespace)
           (hide (make-string-parser ")"))))

    (setf (gethash :option grammar)
          (make-cat
           (hide (make-string-parser "["))
           (make-nt :opt-whitespace)
           (make-nt :alternation)
           (make-nt :opt-whitespace)
           (hide (make-string-parser "]"))))

    (setf (gethash :hide grammar)
          (make-cat
           (hide (make-string-parser "<"))
           (make-nt :opt-whitespace)
           (make-nt :alternation)
           (make-nt :opt-whitespace)
           (hide (make-string-parser ">"))))

    ;; Lookahead
    (setf (gethash :look grammar)
          (make-cat
           (hide (make-string-parser "&"))
           (make-nt :opt-whitespace)
           (make-nt :element)))

    (setf (gethash :neg grammar)
          (make-cat
           (hide (make-string-parser "!"))
           (make-nt :opt-whitespace)
           (make-nt :element)))

    ;; Character values
    (setf (gethash :char-val grammar)
          (make-alt
           ;; Double-quoted string
           (make-cat
            (hide (make-string-parser "\""))
            (make-star (make-regexp-parser "[\\x20-\\x21\\x23-\\x7E]"))
            (hide (make-string-parser "\"")))
           ;; Single-quoted string
           (make-cat
            (hide (make-string-parser "'"))
            (make-star (make-regexp-parser "[\\x20-\\x26\\x28-\\x7E]"))
            (hide (make-string-parser "'")))))

    ;; Numeric values
    (setf (gethash :num-val grammar)
          (make-cat
           (hide (make-string-parser "%"))
           (make-alt
            (make-nt :bin-val)
            (make-nt :dec-val)
            (make-nt :hex-val))))

    (setf (gethash :bin-val grammar)
          (make-cat
           (hide (make-string-parser "b"))
           (make-nt :bin-char)
           (make-opt
            (make-alt
             (make-plus
              (make-cat (hide (make-string-parser "."))
                        (make-nt :bin-char)))
             (make-cat (make-string-parser "-")
                       (make-nt :bin-char))))))

    (setf (gethash :bin-char grammar)
          (make-plus (make-regexp-parser "[01]")))

    (setf (gethash :dec-val grammar)
          (make-cat
           (hide (make-string-parser "d"))
           (make-nt :dec-char)
           (make-opt
            (make-alt
             (make-plus
              (make-cat (hide (make-string-parser "."))
                        (make-nt :dec-char)))
             (make-cat (make-string-parser "-")
                       (make-nt :dec-char))))))

    (setf (gethash :dec-char grammar)
          (make-plus (make-regexp-parser "[0-9]")))

    (setf (gethash :hex-val grammar)
          (make-cat
           (hide (make-string-parser "x"))
           (make-nt :hex-char)
           (make-opt
            (make-alt
             (make-plus
              (make-cat (hide (make-string-parser "."))
                        (make-nt :hex-char)))
             (make-cat (make-string-parser "-")
                       (make-nt :hex-char))))))

    (setf (gethash :hex-char grammar)
          (make-plus (make-regexp-parser "[0-9a-fA-F]")))

    ;; Regexp extension (not standard ABNF)
    (setf (gethash :regexp grammar)
          (make-alt
           (make-regexp-parser "#'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'")
           (make-regexp-parser "#\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"")))

    ;; Apply standard reductions
    (iparse/reduction:apply-standard-reductions grammar)
    grammar))

(defvar *abnf* (make-abnf-grammar)
  "The meta-grammar for parsing ABNF notation.")


;;;; Build Rule - Convert ABNF Parse Tree to Combinators

(defun parse-int-radix (str radix)
  "Parse string as integer in given radix."
  (parse-integer str :radix radix))

(defun get-char-combinator (&rest nums)
  "Create combinator for character value(s).
Single char, range (with -), or sequence (with .)."
  (cond
    ;; Range: n-m
    ((and (= (length nums) 3)
          (equal (second nums) "-"))
     (make-char-range-parser (first nums) (third nums)))
    ;; Sequence of chars
    (t
     (apply #'make-cat
            (mapcar (lambda (n) (make-char-range-parser n n)) nums)))))

(defun extract-string-value (tree)
  "Extract the string value from a tree node, unwrapping as needed."
  (let ((unwrapped (iparse/cfg::unwrap-tree tree)))
    (cond
      ((stringp unwrapped) unwrapped)
      ((and (consp unwrapped) (keywordp (first unwrapped)))
       ;; Hiccup node like (:RULENAME "greeting")
       (extract-string-value (second unwrapped)))
      (t (error "Cannot extract string from: ~A" tree)))))

(defun build-abnf-rule (tree)
  "Convert an ABNF parse tree node to a parser combinator."
  (let ((tag (iparse/cfg::tree-tag tree))
        (contents (iparse/cfg::tree-contents tree)))
    (case tag
      (:rule
       (destructuring-bind (rulename-left alternation) contents
         (list (intern (string-upcase (extract-string-value rulename-left)) :keyword)
               (build-abnf-rule alternation))))

      (:hide-tag-rule
       (destructuring-bind (hide-tag alternation) contents
         (let ((name (extract-string-value hide-tag)))
           (list (intern (string-upcase name) :keyword)
                 (hide-tag (build-abnf-rule alternation))))))

      (:rulename-left
       (extract-string-value tree))

      (:rulename-right
       (make-nt (intern (string-upcase (extract-string-value tree)) :keyword)))

      (:alternation
       (if (= (length contents) 1)
           (build-abnf-rule (first contents))
           (apply #'make-alt (mapcar #'build-abnf-rule contents))))

      (:concatenation
       (if (= (length contents) 1)
           (build-abnf-rule (first contents))
           (apply #'make-cat (mapcar #'build-abnf-rule contents))))

      (:repetition
       (if (= (length contents) 1)
           (build-abnf-rule (first contents))
           (destructuring-bind (repeat-node element) contents
             (let* ((repeat-contents (iparse/cfg::tree-contents repeat-node))
                    (repeat-info (parse-repeat repeat-contents))
                    (element-parser (build-abnf-rule element)))
               (apply-repeat repeat-info element-parser)))))

      (:repeat
       tree)  ; Handled by :repetition

      (:option
       (make-opt (build-abnf-rule (first contents))))

      (:hide
       (hide (build-abnf-rule (first contents))))

      (:look
       (make-look (build-abnf-rule (first contents))))

      (:neg
       (make-neg (build-abnf-rule (first contents))))

      (:group
       (build-abnf-rule (first contents)))

      (:element
       ;; Element wraps another node
       (build-abnf-rule (first contents)))

      (:char-val
       ;; Contents are individual characters from the star parser
       (let ((chars (mapcar (lambda (c)
                              (let ((u (iparse/cfg::unwrap-tree c)))
                                (if (stringp u) u (string u))))
                            contents)))
         (make-string-ci-parser (apply #'concatenate 'string chars))))

      (:num-val
       ;; Numeric value - delegate to the specific type (bin/dec/hex)
       (build-abnf-rule (first contents)))

      (:bin-val
       (apply #'get-char-combinator
              (parse-num-val contents 2)))

      (:dec-val
       (apply #'get-char-combinator
              (parse-num-val contents 10)))

      (:hex-val
       (apply #'get-char-combinator
              (parse-num-val contents 16)))

      (:regexp
       (let ((content (iparse/cfg::tree-content tree)))
         (make-regexp-parser (iparse/cfg::process-regexp content))))

      (otherwise
       (if (stringp (iparse/cfg::unwrap-tree tree))
           (iparse/cfg::unwrap-tree tree)
           (error "Unknown ABNF parse tree node: ~A" tree))))))

(defun parse-repeat (contents)
  "Parse repeat specification, returning (low . high) or NIL."
  (cond
    ((null contents) nil)
    ((= (length contents) 1)
     (let ((item (iparse/cfg::unwrap-tree (first contents))))
       (cond
         ((equal item "*") (cons 0 nil))
         ((stringp item) (let ((n (parse-integer item)))
                           (cons n n)))
         (t (cons 1 1)))))
    ((= (length contents) 2)
     (let ((first-item (iparse/cfg::unwrap-tree (first contents)))
           (second-item (iparse/cfg::unwrap-tree (second contents))))
       (cond
         ((equal first-item "*")
          (cons 0 (parse-integer second-item)))
         (t
          (cons (parse-integer first-item) nil)))))
    ((= (length contents) 3)
     (cons (parse-integer (iparse/cfg::unwrap-tree (first contents)))
           (parse-integer (iparse/cfg::unwrap-tree (third contents)))))
    (t (cons 0 nil))))

(defun apply-repeat (repeat-info element)
  "Apply repeat specification to element parser."
  (if (null repeat-info)
      element
      (let ((low (car repeat-info))
            (high (cdr repeat-info)))
        (cond
          ((and (zerop low) (null high)) (make-star element))
          ((and (= low 1) (null high)) (make-plus element))
          ((and (zerop low) (eql high 1)) (make-opt element))
          ((and low high (= low high) (= low 1)) element)
          (t (make-rep low (or high most-positive-fixnum) element))))))

(defun parse-num-val (contents radix)
  "Parse numeric value components, returning list of integers or ('-' . integers)."
  (let ((result nil))
    (dolist (item contents)
      (let ((unwrapped (iparse/cfg::unwrap-tree item)))
        (cond
          ((equal unwrapped "-")
           (push "-" result))
          ((stringp unwrapped)
           (push (parse-int-radix unwrapped radix) result))
          ((eq (iparse/cfg::tree-tag item) :bin-char)
           (push (parse-int-radix (apply #'concatenate 'string
                                         (mapcar #'iparse/cfg::unwrap-tree
                                                 (iparse/cfg::tree-contents item)))
                                  radix)
                 result))
          ((eq (iparse/cfg::tree-tag item) :dec-char)
           (push (parse-int-radix (apply #'concatenate 'string
                                         (mapcar #'iparse/cfg::unwrap-tree
                                                 (iparse/cfg::tree-contents item)))
                                  radix)
                 result))
          ((eq (iparse/cfg::tree-tag item) :hex-char)
           (push (parse-int-radix (apply #'concatenate 'string
                                         (mapcar #'iparse/cfg::unwrap-tree
                                                 (iparse/cfg::tree-contents item)))
                                  radix)
                 result)))))
    (nreverse result)))


;;;; Merge Core Rules

(defun merge-core-rules (grammar)
  "Merge referenced ABNF core rules into grammar."
  (let ((referenced (collect-all-non-terminals grammar)))
    (dolist (rule-name referenced)
      (let ((core-rule (gethash rule-name *abnf-core*)))
        (when (and core-rule (not (gethash rule-name grammar)))
          (setf (gethash rule-name grammar) core-rule))))
    grammar))

(defun collect-all-non-terminals (grammar)
  "Collect all non-terminal references from grammar."
  (let ((result nil))
    (maphash (lambda (key parser)
               (declare (ignore key))
               (setf result (append result (iparse/cfg::collect-non-terminals parser))))
             grammar)
    (remove-duplicates result)))


;;;; Public Interface

(defun build-abnf-parser (grammar-string &key (start nil))
  "Build a parser from an ABNF grammar string.
Returns (values grammar start-rule)."
  (multiple-value-bind (result success-p)
      (iparse/gll:parse-grammar *abnf* :rulelist grammar-string)
    (unless success-p
      (error "Failed to parse ABNF grammar:~%~A" result))

    ;; Convert AFS/metaobject to list
    (let* ((rules (cond
                    ((iparse/afs:afs-p result)
                     (iparse/afs:afs-to-list result))
                    ((iparse/util:metaobject-p result)
                     (let ((val (iparse/util:metaobject-value result)))
                       (if (iparse/afs:afs-p val)
                           (iparse/afs:afs-to-list val)
                           val)))
                    (t result)))
           (grammar (make-hash-table :test 'eq))
           (first-rule nil))

      (dolist (rule-tree rules)
        (destructuring-bind (keyword parser) (build-abnf-rule rule-tree)
          (unless first-rule
            (setf first-rule keyword))
          ;; Handle incremental rule definition (=/)
          (let ((existing (gethash keyword grammar)))
            (if existing
                (setf (gethash keyword grammar)
                      (make-alt existing parser))
                (setf (gethash keyword grammar) parser)))))

      (iparse/reduction:apply-standard-reductions grammar)
      (merge-core-rules grammar)
      (iparse/cfg::check-grammar grammar)

      (values grammar (or start first-rule)))))

(defun abnf (grammar-string)
  "Parse ABNF grammar string and return the grammar hash table."
  (build-abnf-parser grammar-string))
@
